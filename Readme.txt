-----------------------------------ファイル名一覧------------------------------------------
makeTestData.py (実行すると、test.log　が出力されます。)
test.log　(テスト用ログファイル、データ数は10**5行です。)

question1.py  
question2.py 
question3.py 
question4.py （それぞれ設問1～4に対応）

以上のpythonファイルを、入力ファイル（test.log）と同じディレクトリに置いて、
python3.6以降の環境（f-string使っています）で実行すると、

同じディレクトリに、結果が書き込まれた

output1.txt
output2.txt
output3.txt
output4.txt

がそれぞれ出力されます。

（結局、question4.pyが設問1～4を包摂したプログラムになっています。）


--------------------------------テストデータについて-------------------------------------------
　
ping応答時間は、対数正規分布に従う乱数（を少し改良したもの)を与えており、
前回値との相関がなく、サブネットの故障も表現できていません。
　
サブネットの故障を検出しやすいようにするために、
管理するサーバアドレスは6種類で、2種類ずつ共通のネットワークアドレスを持つ状況のデータを作り、
question4.py（設問4）ではパラメータN＝3としています。
(サブネット故障の検出数は少ないですが、正常に検出しているはずです。)

現実的でないテストデータですが、プログラム自体は、正常であるはずです。



--------------------------------プログラムの内容について----------------------------------------

今回は、test.logを読み込んでチェックするプログラムになっていますが、
現実的な状況は、リアルタイムで更新されるlogファイルをチェックする必要があると思うので、
そのような状況にも（少し修正すると？）対応できるようなプログラムを心掛けました。
（入力データの大きさに依存しないプログラムを作成しました。）


また、管理しているサーバーのアドレスは事前にわかっているかもしれませんが、
入力されたアドレスから自動的にネットワークアドレスごとに分類するようにしました。
また、サブネットの故障（サブネット内のサーバが全て故障）を検出にあたって、
稼働中のサーバーのみを対象とする必要があるので、連続〇回入力されていない場合、
停止中（or使わなくなった）と見なすようにしています。
（もちろん、入力が始まると自動的に稼働中のサーバと見なすようになっています。)
（〇は、SeverChangeParaというパラメータで与えました。）


また、過負荷状態について

　・過負荷状態・・・・直近ｍ回のping応答時間の合計値が(t*m)以上。
                 　 　タイムアウトしている場合、t+dt　で近似。(dtもパラメータ)
  ・過負荷状態期間・・過負荷状態が開始してから、過負荷状態でない入力だった時までの期間

と解釈しています。
（ほぼ設問通りの解釈で、タイムアウト時の応答時間についてのみ、補って解釈しています。）



また、サブネットの故障について

　　　・サブネットが故障状態・・サブネット内のサーバが全て故障

と設問通り解釈していますが、
　　　
　　　・サブネット内の全てのサーバー・・サブネット内の稼働中の全てのサーバー

としています。
(といっても、途中で停止・再開するようなテストデータでないですが。)


---------------プログラムの流れ----------------

	①管理データ＆パラメータ
	　　　　  ↓
	　　　　②関数
		  ↓
      　　　　③mainの処理

となっています。

-------------------------------------------------
以下、question4.pyについて。(他のプログラムにも、それぞれ部分的に含まれています。)


①管理データ＆パラメーター
　
プログラム内にもコメントで記述しています。

・Ｎ、ｍ、ｔ、dt、SeverChangePara　がパラメータです。
　（以降の説明に出てきます。）


アドレス別にデータを保持するために、基本的には、keyに（サーバー）アドレスを持つ辞書型を使って管理します。

　
・temp_dict(1~3)={}  →期間を調べるために、keyにアドレス、valueに故障or過負荷orサブネット故障開始時間を保持しています。


・SeriesTimeoutConter = collections.Counter()  →　タイムアウトが何回連続しているか調べるために、 keyにアドレス、
						　　valueに連続タイムアウト回数を保持しています。



・Q_dict = {}
・Ping_sum = {}　→この2つは、直近m回の合計値を計算するための物です。		　　
		　それぞれ、valueに、ping応答時間が入ったキュー、前回から直近m回の合計値　を保持しています。

		　普通に全部足し算するのではなく、前回からの合計値　- 直近m+1個目　+　現在値　と計算するためです。
（計算量が特に減るわけでもなく、前回値を保持する必要があったり、無駄なことをしてしまった気がします・・・）


	
・SubNet_dict = collections.defaultdict(list)
			→keyに'ネットワーク'アドレス、valueに、そこに属するサーバーアドレスのリスト。

・Now_accident = []
	　　　　　　　　→現在、故障中（N回以上連続タイムアウト）のサーバーアドレスを保持するリスト。
　　　
 この2つは、サブネットが故障しているかチェックするために使います。　　　　　　　　　
　※この2つはリストの代わりに集合を使った方が良かったかと思います。
    （ＩＮ演算を行う場面がある(集合の方が速い)+重複をしないかのチェックをしなくてもよくなるため。）

　   今回の状況(要素数が少ない)ではあまり変わらないと思うのでそのままにしています。　　　　　　　　　

　　
　

　(SeverChangePara = 10**3)
・SeverConter = collections.Counter()　
			　　　→サブネットの故障を正しくチェックするため（どのサーバーが稼働中かどうかチェックするため）、
			　　　　keyにアドレス、valueに全入力の内、連続で入力されていない回数を保持しています。
　　　　　　　　　　　　　　　　
　連続で入力されていない回数が、SeverChangePara回以上になると、稼働していないとみなし、上記のSubNet_dictから取り除きます。


								


②関数

　time_sep(t1,t2)　→　引数に（Str型の）開始時刻と終了時刻をうけて、（出力用に）整えて返します。


　calc_sumping(Q,p)　→　引数に直近m+1個のインデックスが入ったキューと、前回から直近m回のping合計値を受け取り、
			 今回から直近m回のping合計値を返します。また、ここでキューから要素を1つ取り出しm個にします。


  net_classify(a) →　引数にサーバーアドレスを受け取って、ネットワークアドレス毎に分類します。
    		　　　また、稼働していないサーバーアドレスを取り除きます。



③mainの処理

　入力を一行ずつ、Time、Address、Ping　と3つの変数で受け取る。（よって、入力データが溜まっていかない）
　　　　　↓
　ネットワークアドレス毎に、稼働しているサーバーを分類する。また、稼働していないサーバーアドレスを取り除く。
　　　　　↓
　過負荷状態をチェック
　　　　　↓
　故障をチェック
	　↓
　サブネットの故障をチェック
　　　　　↓
　以下繰り返し


--------------------------------------------------

また、出力のパターンは、過負荷状態（サーバー単体の）故障、サブネットの故障の3パターンあります。
出力例は以下です。

　サーバーアドレス:10.20.30.1/16が過負荷状態　2020-10-19 07:02:08から,2020-10-19 07:02:10までの 2.0秒間
　サーバーアドレス:10.20.30.2/16が故障　2020-10-19 07:19:56から,2020-10-19 07:20:28までの 32.0秒間 (連続4回タイムアウト)
　ネットワークアドレス:10.20が故障　2020-10-19 07:20:17から,2020-10-19 07:20:28までの 11.0秒間





よろしくお願いいたします。












